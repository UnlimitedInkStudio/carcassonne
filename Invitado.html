<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Carcassonne</title>
<style>
  @keyframes valid{
    0% {background-color: aqua;}
    25%{background-color: white;}
    50%{background-color: aqua;}
    75%{background-color: white;}
    100%{background-color: aqua;}
  }
  body { font-family: Arial; text-align: center; background: #f0f0f0; margin: 0; }
  #contenedor { display: flex; flex-direction: column; align-items: center; position: relative; }
  #tablero {
    width: 900px; height: 900px;
    display: grid;
    grid-template-columns: repeat(15, 60px);
    grid-template-rows: repeat(15, 60px);
    gap: 1px;
    background-color: #ccc;
    border: 3px solid #333;
    margin-top: 10px;
    z-index: 1; /* asegurar que el avatar pueda colocarse por encima */
  }
  .celda { width: 60px; height: 60px; background: #fff; border: 1px solid #aaa; position: relative; }
  .valida { animation: valid 5s infinite; }
  .loseta { width: 60px; height: 60px; position: absolute; top: 0; left: 0; transform-origin: center center; touch-action: none; }
  /* Asegurar que las losetas queden por encima de la barra de controles */
  .loseta { z-index: 2000; }
  .meeple { width: 30px; height: 30px; position: absolute; bottom: 5px; right: 5px; }
  #barra-controles { position: sticky; bottom: 0; background: #222; padding: 10px; width: 100%; color: white; z-index: 1000; }
  #barra-controles button { margin: 5px; padding: 8px 14px; font-size: 14px; cursor: pointer; }
  #info { margin-top: 10px; font-weight: bold; }
  /* Avatar del jugador. Pone el avatar "por encima" usando fixed y z-index alto */
  #jugador-actual {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 120px;
    height: 120px;
    border: 3px solid #333;
    border-radius: 10px;
    background-color: #fff;
    z-index: 99999; /* siempre por encima del tablero */
    pointer-events: auto; /* deja activo el avatar (cambiar a 'none' si quieres que toques pasen a la cuadricula) */
  }
  /* Resalto mientras se arrastra con el dedo */
  .arrastrando { outline: 3px dashed #2ecc71; }
  
  /* Responsive: alejamos el avatar del tablero en pantallas peque침as */
  @media (max-width: 600px) {
    #jugador-actual {
      position: fixed;
      top: 8px;
      right: 8px;
      width: 84px;
      height: 84px;
      z-index: 99999;
      pointer-events: none; /* que no bloquee toques en movil sobre el tablero */
    }
    /* Empujar el tablero para dar espacio visual */
    #tablero {
      margin-top: 120px;
      width: calc(100vw - 20px);
      height: calc(100vw - 20px);
    }
  }

  /* Responsive: mover el avatar lejos del tablero en pantallas peque침as */
  @media (max-width: 600px) {
    #jugador-actual {
      position: fixed;
      top: 8px;
      right: 8px;
      width: 84px;
      height: 84px;
      z-index: 1200;
      border-radius: 12px;
    }
    /* Dar espacio visual y que no tape la cuadricula */
    #tablero {
      margin-top: 120px;
      width: calc(100vw - 20px);
      height: calc(100vw - 20px);
      max-width: 900px;
      max-height: 900px;
    }
  }

  @media (min-width: 601px) and (max-width: 900px) {
    #jugador-actual {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 100px;
      height: 100px;
    }
  }
</style>
</head>
<body>
<div id="contenedor">
  <h2>Carcassonne</h2>
  <img id="jugador-actual" src="imagenes/personaje_rojo.png" alt="Jugador Actual">
  <div id="tablero"></div>
  <div id="info"></div>
</div>

<div id="barra-controles">
  <button id="rotar">Rotar loseta</button>
  <button id="confirmar">Confirmar colocaci칩n</button>
</div>

<script>
let jugador = 1;
let losetasRestantes = 72;
let rotacion = 0;
let losetaActual = null;
let celdaSeleccionada = null;
let tipoActual = null;
let indiceActual = null;

const tablero = document.getElementById("tablero");
const info = document.getElementById("info");
const imgJugadorActual = document.getElementById("jugador-actual");
let celdas = [];
let estadoTablero = Array(225).fill(null);

let puntaje = [
  {vagos: 0, ladrones: 0, caballeros: 0, paladines: 0, total: 0, diario: 0, ultimo: 0},
  {vagos: 0, ladrones: 0, caballeros: 0, paladines: 0, total: 0, diario: 0, ultimo: 0},
  {vagos: 0, ladrones: 0, caballeros: 0, paladines: 0, total: 0, diario: 0, ultimo: 0},
  {vagos: 0, ladrones: 0, caballeros: 0, paladines: 0, total: 0, diario: 0, ultimo: 0}
];

window.jugador_rojo = 0;
window.jugador_violeta = 0;
window.jugador_verde = 0;
window.jugador_amarillo = 0;

function actualizarVariablesJugadoresPorColor(){
  window.jugador_rojo = puntaje[0].total;
  window.jugador_violeta = puntaje[1].total;
  window.jugador_verde = puntaje[2].total;
  window.jugador_amarillo = puntaje[3].total;
}

actualizarVariablesJugadoresPorColor();

let puntajeDiarioHist = [[], [], [], []];
const puntosPorMeeple = { vago: 3, ladron: 1, caballero: 4, paladin: 5 };

let registros = [];

/* ----------------------------------------
   Soporte t치ctil / pointer (global)
   - Las funciones usan la variable global losetaActual
   - Se registran listeners cuando se crea una loseta
-----------------------------------------*/
let _touchActive = false;
let _touchOffsetX = 0;
let _touchOffsetY = 0;
let _pointerId = null;

function onPointerStart(e) {
  if (!losetaActual) return;
  e.preventDefault();
  const clientX = (e.clientX !== undefined) ? e.clientX : (e.touches && e.touches[0].clientX);
  const clientY = (e.clientY !== undefined) ? e.clientY : (e.touches && e.touches[0].clientY);
  _touchActive = true;
  if (e.pointerId) _pointerId = e.pointerId;
  const rect = losetaActual.getBoundingClientRect();
  _touchOffsetX = clientX - rect.left;
  _touchOffsetY = clientY - rect.top;
  losetaActual.style.position = 'absolute';
  losetaActual.style.zIndex = 9999;
  losetaActual.draggable = false;
  try { if (e.pointerId) losetaActual.setPointerCapture(e.pointerId); } catch (err) {}
}

function onPointerMove(e) {
  if (!_touchActive || !losetaActual) return;
  e.preventDefault();
  const clientX = (e.clientX !== undefined) ? e.clientX : (e.touches && e.touches[0].clientX);
  const clientY = (e.clientY !== undefined) ? e.clientY : (e.touches && e.touches[0].clientY);
  losetaActual.style.left = (clientX - _touchOffsetX) + 'px';
  losetaActual.style.top = (clientY - _touchOffsetY) + 'px';
  // resaltar celda sobre la que est치 el dedo
  const under = document.elementFromPoint(clientX, clientY);
  celdas.forEach(c => c.classList.remove('arrastrando'));
  if (under && under.classList && under.classList.contains('celda')) under.classList.add('arrastrando');
}

function onPointerEnd(e) {
  if (!_touchActive || !losetaActual) return;
  _touchActive = false;
  const clientX = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientX : e.clientX;
  const clientY = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientY : e.clientY;
  const under = document.elementFromPoint(clientX, clientY);
  celdas.forEach(c => c.classList.remove('arrastrando'));
  try { if (e.pointerId) losetaActual.releasePointerCapture(e.pointerId); } catch (err) {}

  if (under && under.classList && under.classList.contains('celda')) {
    const index = celdas.indexOf(under);
    // Llamar a mismo comportamiento que drop
    colocarTemporal({ preventDefault: () => {} }, under, index);
  } else {
    // si no solt칩 sobre el tablero, devolver a la bandeja
    losetaActual.style.left = '50%';
    losetaActual.style.top = '90%';
    losetaActual.style.transform = `translate(-50%, -50%) rotate(${rotacion}deg)`;
    losetaActual.style.zIndex = '';
    losetaActual.draggable = true;
  }
}

function cleanupPointerListeners() {
  try {
    losetaActual.removeEventListener('pointerdown', onPointerStart);
    window.removeEventListener('pointermove', onPointerMove);
    window.removeEventListener('pointerup', onPointerEnd);
    losetaActual.removeEventListener('touchstart', onPointerStart);
    window.removeEventListener('touchmove', onPointerMove);
    window.removeEventListener('touchend', onPointerEnd);
  } catch (e) {}
}
/* -------------------------------------- */

for (let i = 0; i < 225; i++) {
  const celda = document.createElement("div");
  celda.classList.add("celda");
  celda.dataset.ocupada = "false";
  celda.addEventListener("dragover", e => e.preventDefault());
  celda.addEventListener("drop", e => colocarTemporal(e, celda, i));
  tablero.appendChild(celda);
  celdas.push(celda);
}

const tiposLoseta = [
  { nombre: "Camino Recto", imagen: "imagenes/camino_recto.png", caminos: [0,2], maxRot: 1 },
  { nombre: "Camino Curva", imagen: "imagenes/camino_curva.png", caminos: [1,2], maxRot: 3 },
  { nombre: "Camino Cruce", imagen: "imagenes/camino_cruce.png", caminos: [0,1,2,3], maxRot: 0 },
  { nombre: "Ciudad Especial", imagen: "imagenes/ciudad_especial.png", caminos: [0,1,2,3], maxRot: 0 },
  { nombre: "Iglesia", imagen: "imagenes/iglesia.png", caminos: [0,1,2,3], maxRot: 0 }
];

const centro = 7 * 15 + 7;
colocarLosetaFija(centro, tiposLoseta[2], 0);
turnoJugador();

function actualizarImagenJugador() {
  const colores = ["rojo", "violeta", "verde", "amarillo"];
  imgJugadorActual.src = `imagenes/personaje_${colores[jugador - 1]}.png`;
}

function turnoJugador() {
  if (losetasRestantes <= 0) { finalizarJuego(); return; }
  actualizarImagenJugador();
  alert(`Turno del jugador ${jugador}\nLosetas restantes: ${losetasRestantes}\nPuntos actuales: ${puntaje[jugador-1].total} pts`);
  info.innerText = `Jugador ${jugador} | Losetas restantes: ${losetasRestantes} | Puntos: ${puntaje[jugador-1].total} pts`;
  prepararNuevaLoseta();
  marcarEspaciosValidos();
}

function prepararNuevaLoseta() {
  if (losetaActual) {
    // limpiar listeners previos si hay uno
    try { cleanupPointerListeners(); } catch(e){};
    losetaActual.remove();
  }
  let random = Math.random();
  if (random < 0.07) {
    tipoActual = tiposLoseta[4];
  } else if (random < 0.22) {
    tipoActual = tiposLoseta[3];
  } else {
    tipoActual = tiposLoseta[Math.floor(Math.random() * 3)];
  }
  losetaActual = document.createElement("img");
  losetaActual.src = tipoActual.imagen;
  losetaActual.classList.add("loseta");
  losetaActual.draggable = true;
  losetaActual.dataset.tipo = tipoActual.nombre;
  losetaActual.style.position = "absolute";
  losetaActual.style.left = "50%";
  losetaActual.style.top = "90%";
  losetaActual.style.transform = "translate(-50%, -50%) rotate(0deg)";
  losetaActual.style.zIndex = 2000; // default z-index para que est칠 por encima de los botones
  losetaActual.addEventListener("dragstart", e => { e.dataTransfer.setData("text/plain", "loseta"); });

  document.body.appendChild(losetaActual);
  rotacion = 0;

  // registrar listeners para pointer/touch (soportados en m칩viles)
  losetaActual.addEventListener('pointerdown', onPointerStart);
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerEnd);
  losetaActual.addEventListener('touchstart', onPointerStart, { passive: false });
  window.addEventListener('touchmove', onPointerMove, { passive: false });
  window.addEventListener('touchend', onPointerEnd, { passive: false });
}

function adyacentes(i) {
  const cols = 15;
  const arr = [];
  if (i % cols !== 0) arr.push(i - 1);
  if (i % cols !== cols - 1) arr.push(i + 1);
  if (i - cols >= 0) arr.push(i - cols);
  if (i + cols < 225) arr.push(i + cols);
  return arr;
}

function obtenerDireccionesActivas(tipo, rot) {
  switch (tipo.nombre) {
    case "Camino Recto":
      return rot % 180 === 0 ? [0,2] : [1,3];
    case "Camino Curva":
      if (rot === 0) return [1,2];
      if (rot === 90) return [2,3];
      if (rot === 180) return [3,0];
      if (rot === 270) return [0,1];
      return [];
    case "Camino Cruce":
    case "Ciudad Especial":
    case "Iglesia":
      return [0,1,2,3];
    default:
      return [];
  }
}

function esColocacionValida(index) {
  if (!tipoActual) return false;
  if (tipoActual.nombre === "Camino Cruce") {
    return celdas[index].dataset.ocupada === "false";
  }
  const cols = 15;
  const ladosActivos = obtenerDireccionesActivas(tipoActual, rotacion);
  const vecinos = [
    { idx: index - 1, dir: 0 },
    { idx: index + 1, dir: 1 },
    { idx: index - cols, dir: 2 },
    { idx: index + cols, dir: 3 }
  ];
  const dirOpuesta = [1, 0, 3, 2];
  for (let v of vecinos) {
    const vecinoIdx = v.idx;
    const dir = v.dir;
    if (vecinoIdx < 0 || vecinoIdx >= 225) continue;
    if (dir === 0 && index % cols === 0) continue;
    if (dir === 1 && index % cols === cols - 1) continue;
    const vecinoData = estadoTablero[vecinoIdx];
    if (!vecinoData) continue;
    const vecinoLados = obtenerDireccionesActivas(vecinoData.tipo, vecinoData.rot);
    const ladoTiene = ladosActivos.includes(dir);
    const vecinoTiene = vecinoLados.includes(dirOpuesta[dir]);
    if (ladoTiene && !vecinoTiene) return false;
    if (!ladoTiene && vecinoTiene) return false;
  }
  return true;
}

function marcarEspaciosValidos() {
  celdas.forEach(c => c.classList.remove("valida"));
  if (!tipoActual) return;
  celdas.forEach((c, i) => {
    if (c.dataset.ocupada === "true") return;
    const tieneVecino = adyacentes(i).some(a => estadoTablero[a]);
    if (tieneVecino && esColocacionValida(i)) c.classList.add("valida");
  });
}

function colocarLosetaFija(index, tipo, rot) {
  const celda = celdas[index];
  celda.dataset.ocupada = "true";
  celda.classList.remove("valida");
  celda.innerHTML = "";
  const fija = document.createElement("img");
  fija.src = tipo.imagen;
  fija.classList.add("loseta");
  fija.style.transform = `rotate(${rot}deg)`;
  fija.style.zIndex = 2000; // asegurar que la loseta colocada est칠 por encima de la barra
  celda.appendChild(fija);
  estadoTablero[index] = { tipo: tipo, rot };
}

function colocarTemporal(e, celda, index) {
  e.preventDefault();
  if (!celda.classList.contains("valida")) return;
  if (celda.dataset.ocupada === "true") return;
  if (!esColocacionValida(index)) {
    alert("No se puede colocar aqu칤 (los caminos no coinciden)");
    return;
  }
  if (celdaSeleccionada && celdaSeleccionada !== celda) {
    celdaSeleccionada.innerHTML = "";
    celdaSeleccionada.classList.add("valida");
  }
  celdaSeleccionada = celda;
  indiceActual = index;
  celda.innerHTML = "";
  celda.appendChild(losetaActual);
  losetaActual.style.position = "relative";
  losetaActual.style.left = "0";
  losetaActual.style.top = "0";
  losetaActual.style.transform = `rotate(${rotacion}deg)`;
  losetaActual.draggable = false;
  celda.classList.remove("valida");

  // Quitar listeners de pointer (ya qued칩 colocada)
  cleanupPointerListeners();
}

document.getElementById("rotar").onclick = () => {
  if (!losetaActual) return;
  rotacion += 90;
  if (rotacion >= 360) rotacion = 0;
  losetaActual.style.transform = `rotate(${rotacion}deg)`;
  marcarEspaciosValidos();
};

document.getElementById("confirmar").onclick = () => {
  if (!celdaSeleccionada) {
    alert("Coloca la loseta en una posici칩n v치lida antes de confirmar.");
    return;
  }
  // limpiar listeners si quedan
  cleanupPointerListeners();
  colocarLosetaFija(indiceActual, tipoActual, rotacion);
  losetaActual.remove();
  losetaActual = null;
  celdaSeleccionada = null;
  losetasRestantes--;
  mostrarOpcionesMeeple();
};

function mostrarOpcionesMeeple() {
  const colores = ["rojo","violeta","verde","amarillo"];
  const color = colores[jugador-1];
  const barra = document.getElementById("barra-controles");
  if (tipoActual.nombre === "Ciudad Especial") {
    barra.innerHTML = `
      <button id="btnCaballero">Caballero_${color}</button>
      <button id="btnNada">Nada</button>`;
    document.getElementById("btnCaballero").onclick = () => finTurno("caballero", color);
    document.getElementById("btnNada").onclick = () => finTurno(null, null);
  } else if (tipoActual.nombre === "Iglesia") {
    barra.innerHTML = `
      <button id="btnPaladin">Paladin_${color}</button>
      <button id="btnNada">Nada</button>`;
    document.getElementById("btnPaladin").onclick = () => finTurno("paladin", color);
    document.getElementById("btnNada").onclick = () => finTurno(null, null);
  } else {
    barra.innerHTML = `
      <button id="btnLadron">Ladron_${color}</button>
      <button id="btnVago">Vago_${color}</button>
      <button id="btnNada">Nada</button>`;
    document.getElementById("btnLadron").onclick = () => finTurno("ladron", color);
    document.getElementById("btnVago").onclick = () => finTurno("vago", color);
    document.getElementById("btnNada").onclick = () => finTurno(null, null);
  }
}

function finTurno(tipoMeeple, color) {
  const registro = {jugador, loseta: tipoActual.nombre, meeple: tipoMeeple || "ninguno"};
  console.log(`[JUGADOR ${jugador}] coloc칩 loseta: ${tipoActual.nombre} | meeple: ${registro.meeple}`);
  
  if (tipoMeeple) {
    const meeple = document.createElement("img");
    // 游댳 Siempre usa el mismo meeple por color de jugador
    meeple.src = `imagenes/meeple_${color}.png`;
    meeple.classList.add("meeple");
    celdas[indiceActual].appendChild(meeple);
    estadoTablero[indiceActual].meeple = {tipo: tipoMeeple, color: color};

    if (tipoMeeple === "vago") puntaje[jugador-1].vagos++;
    if (tipoMeeple === "ladron") puntaje[jugador-1].ladrones++;
    if (tipoMeeple === "caballero") puntaje[jugador-1].caballeros++;
    if (tipoMeeple === "paladin") puntaje[jugador-1].paladines++;

    const puntos = puntosPorMeeple[tipoMeeple] || 0;
    puntaje[jugador-1].total += puntos;
    puntaje[jugador-1].diario += puntos;
    puntaje[jugador-1].ultimo = puntos;
    actualizarVariablesJugadoresPorColor();

    alert(`Jugador ${jugador}: +${puntos} pts por ${tipoMeeple}. Total actual: ${puntaje[jugador-1].total} pts`);
    console.log(`Jugador ${jugador} sum칩 +${puntos} pts (meeple: ${tipoMeeple}). Total: ${puntaje[jugador-1].total}`);
  } else {
    puntaje[jugador-1].ultimo = 0;
    actualizarVariablesJugadoresPorColor();
  }

  registros.push(registro);

  jugador++;
  if (jugador > 4) jugador = 1;

  if (jugador === 1) {
    let resumenDia = "Fin de d칤a - Puntos por jugador este d칤a:\n";
    for (let i = 0; i < 4; i++) {
      puntajeDiarioHist[i].push(puntaje[i].diario);
      resumenDia += `Jugador ${i+1}: ${puntaje[i].diario} pts\n`;
      puntaje[i].diario = 0;
    }
    alert(resumenDia);
    console.log(resumenDia);
  }

  document.getElementById("barra-controles").innerHTML = `
    <button id="rotar">Rotar loseta</button>
    <button id="confirmar">Confirmar colocaci칩n</button>`;
  document.getElementById("rotar").onclick = () => {
    if (!losetaActual) return;
    rotacion += 90;
    if (rotacion >= 360) rotacion = 0;
    losetaActual.style.transform = `rotate(${rotacion}deg)`;
    marcarEspaciosValidos();
  };
  document.getElementById("confirmar").onclick = () => {
    if (!celdaSeleccionada) {
      alert("Coloca la loseta en una posici칩n v치lida antes de confirmar.");
      return;
    }
    cleanupPointerListeners();
    colocarLosetaFija(indiceActual, tipoActual, rotacion);
    losetaActual.remove();
    losetaActual = null;
    celdaSeleccionada = null;
    losetasRestantes--;
    mostrarOpcionesMeeple();
  };

  turnoJugador();
}

/* Ajuste din치mico opcional de tablero seg칰n avatar (sirve si la altura del avatar var칤a) */
function ajustarTableroPorAvatar() {
  const avatar = document.getElementById('jugador-actual');
  if (!avatar) return;
  const rect = avatar.getBoundingClientRect();
  if (window.innerWidth <= 600) {
    tablero.style.marginTop = (rect.height + 24) + 'px';
  } else {
    tablero.style.marginTop = '10px';
  }
}
window.addEventListener('load', ajustarTableroPorAvatar);
window.addEventListener('resize', ajustarTableroPorAvatar);

function finalizarJuego() {
  alert("춰El juego ha terminado!");
  let resumen = "Puntajes finales:\n";
  for (let i = 0; i < 4; i++) {
    resumen += `Jugador ${i+1}: ${puntaje[i].total} pts\n`;
  }
  alert(resumen);
  console.log(resumen);
}
</script>
</body>
</html>
